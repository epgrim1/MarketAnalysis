from datetime import datetime
import pandas as pd
from SectorRotatorWizard import SectorRotatorWizard  
from EconomicCycleStateClassifier import EconomicCycleStateClassifier
from LiveData import get_live_options_snapshot, process_etf_options

def load_ml_predictions():
    """
    Load the ML output CSV generated by the portfolio_ml.py script.
    Returns a list of dictionaries (one per sector) with ML predictions.
    """
    try:
        ml_df = pd.read_csv("downloads/portfolio_ml_output.csv")
        return ml_df.to_dict(orient="records")
    except Exception as e:
        print(f"Error loading ML predictions: {e}")
        return []

def get_rotation_tickers():
    config = {
        'min_volume': 1000,
        'min_relative_strength': 0.7,
    }
    rotator = SectorRotatorWizard(config)
    rotation_data = rotator.scan_sectors()
    tickers = [item.get("symbol") for item in rotation_data if item.get("symbol")]
    
    # Fallback: if no sector passed the filtering, use all known sectors.
    if not rotation_data:
        print("No sector opportunities passed filtering. Falling back to default sectors.")
        rotation_data = [{"symbol": ticker, "sector": sector} for ticker, sector in rotator.sectors.items()]
        tickers = list(rotator.sectors.keys())
        
    return tickers, rotation_data

def fetch_live_data(ticker_list):
    live_results = []
    for ticker in ticker_list:
        snapshot = get_live_options_snapshot(ticker)
        processed = process_etf_options(ticker, snapshot)
        if processed:
            live_results.append(processed)
    return live_results

def integrated_market_analysis():
    # Obtain sector rotation candidates.
    ticker_list, rotation_data = get_rotation_tickers()
    
    # Load the ML predictions.
    ml_predictions = load_ml_predictions()
    
    # Merge ML data into rotation_data by matching ticker/symbol.
    for sector_info in rotation_data:
        symbol = sector_info.get("symbol")
        for prediction in ml_predictions:
            if prediction.get("sector") == symbol:
                # Add ML fields to the sector_info dictionary.
                sector_info["predicted_move_percent"] = prediction.get("predicted_move_percent")
                sector_info["avg_seasonal_move"] = prediction.get("avg_move")
                sector_info["season_move_std"] = prediction.get("move_std")
                break  # Found the matching prediction, move to next sector.
    
    # Get economic cycle classification.
    cycle_classifier = EconomicCycleStateClassifier()
    cycle_data = cycle_classifier.predict_cycle_state()
    if not cycle_data:
        print("Cycle classification failed. Exiting.")
        return None
    
    # Fetch live options data.
    live_results = fetch_live_data(ticker_list)
    
    # Print cycle state.
    print(f"\nCycle State: {cycle_data['predicted_state']}\n")
    
    # Print sector analysis along with ML predictions.
    for result in rotation_data:
        # Ensure a ticker is printed, even if ML values are missing.
        ticker = result.get('symbol', 'N/A')
        predicted_move = result.get('predicted_move_percent', 'N/A')
        avg_seasonal = result.get('avg_seasonal_move', 'N/A')
        season_std = result.get('season_move_std', 'N/A')
        print(f"Ticker: {ticker}  "
              f"Predicted Move: {predicted_move if predicted_move=='N/A' else f'{predicted_move:.2f}%'}  "
              f"Avg Seasonal Move: {avg_seasonal}  "
              f"Seasonality Std: {season_std}")
    
    # Also print live data for options if available.
    for result in live_results:
        print(f"Ticker: {result['symbol']}  Strike: {result['sample_option_strike']}  Expiry: {result['sample_option_expiry']}")
        
    return {
        "timestamp": datetime.now().strftime('%Y-%m-%d %H:%M:%S'), 
        "cycle_data": cycle_data,
        "rotation_data": rotation_data, 
        "live_data": live_results
    }

if __name__ == "__main__":
    integrated_market_analysis()
